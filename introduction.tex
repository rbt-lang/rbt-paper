
\section{Introduction}
\label{sec:introduction}

The \emph{combinator pattern} is a well-known technique for designing
declarative domain-specific languages (DSLs). This technique views a DSL as an
algebra of self-con\-tained processing blocks, which either come from a set of
predefined atomic \emph{primitives} or are constructed from other blocks using
block \emph{combinators}.

The combinator pattern gives us a roadmap to design a database query language:

\begin{enumerate}
\item
Define the model of a database query.

\item
Describe the set of primitive queries.

\item
Describe combinators for making composite queries.
\end{enumerate}

To elaborate on this idea, we need some sample structured data.  Throughout
this paper, we use a simple database that contains just two classes of
entities: \emph{departments} and \emph{employees}.  Each department entity has
one attribute: \emph{name}.  Each employee entity has three attributes:
\emph{name}, \emph{position} and \emph{salary}.  Each employee belongs to a
department.  An employee may have a \emph{manager}, who is also an employee.

The structure of this database can be visualized as a directed graph, where
entity classes and attribute types become graph nodes, while attributes and
relationships become arcs (see Figure~\ref{fig:sample-schema}).  This diagram
suggests us to view a database as a collection of types and functions.  Namely,
an arc connecting two nodes represents a function with the given types of input
and output, for example
\begin{alignat*}{3}
    & \Department && : \Emp && \to \Dept, \\
    & \Name && : \Dept && \to \Text.
\end{alignat*}
This is known as the functional database model \cite{Kerschberg1976}.

\input{figure-sample-schema}

This model provides us with a starting point on our combinator pattern roadmap.
Indeed, any function on an entity set could be seen as a database query.  Then,
all the attributes and relationships form a set of primitive queries.
Composition of functions becomes a binary query combinator.  With these
considerations, we can write our first composite query.

\begin{demo}
    Given an employee entity, show the name of their department.
    \begin{equation*}
        \Department\To\Name: \Emp \to \Text
    \end{equation*}
\end{demo}

In this example, $\Department\To\Name$ is a query written in Rabbit notation,
$\Emp \to \Text$ is its signature.  The period $(\To)$ denotes the composition
combinator, which is a polymorphic binary operator with a signature
\begin{equation*}
        \placeholder\,\To\,\placeholder : (A \to B,\; B \to C) \to (A \to C).
\end{equation*}

Even though we specified a query model, a set of primitives and one query
combinator, it doesn't yet feel like a proper query language.  Let us discuss
what is missing.

First, it is awkward that a query always demands an input.  It means that we
cannot express an input-free query like \emph{show a list of all
departments}.\footnote{We italicize \emph{business questions} that specify
$\keyword{database}$ $\keyword{queries}$.}

Further, relationships between entities were arbitrarily assigned a direction.
Indeed, we chose to encode the relationship between departments and employees
as a primitive with input $\Emp$ and output $\Dept$.  But this relationship is
symmetric and we may just as well be interested in finding, \emph{for any given
department, the corresponding set of employees}.  This query cannot be encoded
as a function because its signature $\Dept \to \Emp$ would incorrectly imply
that there is exactly one employee per department.  Thus, the query model
is unable to express multivalued or \emph{plural} relationships.

The model also fails to capture the semantics of \emph{optional} attributes and
relationships.  Such is the relationship between employees and their managers,
which, according to Figure~\ref{fig:sample-schema}, should be encoded by a
primitive with signature $\Emp \to \Emp$.  But this signature implies that
every employee must have a manager, which is untrue.  Apparently, pure
functional model is too restrictive to express the variety of relationships
between database entities.

This paper shows how to complete this sketch of a query language.  It is
organized as follows.

In Section~\ref{sec:cardinality}, we introduce query cardinality as a mo\-nadic
structure over its output type, which will allow us to extend our set of
primitive queries.

In Section~\ref{sec:combinators}, we define combinators for data traversal,
aggregation, filtering, sorting, pagination and exploring hierarchical
relationships.

In Section~\ref{sec:quotients}, we define quotient types and show how to use
them for grouping and roll-up operations.

In Section~\ref{sec:context}, we show how to extend the query model with a
comonadic structure over its input type to support context-aware combinators.
This gives us ability to express queries with running aggregates and queries
with parameters.

In Section~\ref{sec:conclusion}, we summarize the query model and briefly
discuss some related work.

