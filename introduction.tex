
\section{Introduction}

\emph{Combinator pattern} (\cite{Barrientos2009}) is a technique for designing
domain-specific languages (DSLs), which prescribes us to model programs in
terms of self-contained domain-specific composable processing blocks.  These
blocks should either come from a set of predefined atomic \emph{primitives} or
be constructed from other blocks using block operations that are called
\emph{combinators}.  To describe a combinator-based DSL, we define its three
components: domain interface, primitives and combinators.

\begin{enumerate}
\item
Domain interface is a type or a type family that characterizes DSL programs.
Usually domain interface takes the form of some particular functional type.
\item
A primitive is an atomic program, an irreducible processing block that can
serve as a basis for other DSL programs.  Typically, the core set of primitives
naturally arises from the problem domain.
\item
A combinator is a rule for combining DSL programs together to form a new
composite program.  Combinators are often represented as higher-order
functions.
\end{enumerate}

The combinator pattern gives us a roadmap for a design of a database query
language:

\begin{enumerate}
\item
Define the query interface.
\item
Describe the set of primitive queries.
\item
Describe operations (combinators) for making composite queries.
\end{enumerate}

To elaborate on these ideas and to demonstrate example queries, we need some
sample structured data.  Throughout this paper, we employ the following
textbook database schema.

The sample database contains two classes of entities: \emph{departments} and
\emph{employees}.

\begin{itemize}
\item
Each department entity has one attribute: \emph{name}.
\item
Each employee entity has three attributes: \emph{name}, \emph{position} and
\emph{salary}.
\item
Each employee belongs to a department.
\item
Some employees may have a manager, who is also an employee.
\end{itemize}

We can picture the structure of this database as a directed graph.  We place
entity classes and attribute types as graph nodes, which lets us draw entity
attributes and relationships as graph arrows (see
figure~\ref{fig:sample-schema}).  This diagram has a straightforward
interpretation in the category of sets, which goes as follows.  Graph nodes
represent sets: entity sets
\begin{equation*}
    \Dept, \qquad \Emp
\end{equation*}
and value sets
\begin{equation*}
    \Text, \qquad \Int.
\end{equation*}
Accordingly, graph arrows represent functions that store data on attributes and
relationships:
\begin{alignat*}{6}
    & \Name && : \Dept && \to \Text, && \quad \Name && : \Emp && \to \Text, \\
    & \Position && : \Emp && \to \Text, && \quad \Salary && : \Emp && \to \Int, \\
    & \Department && : \Emp && \to \Dept, && \quad \Manager && : \Emp && \to \Emp.
\end{alignat*}
This is known as functional database model (\cite{Kerschberg1976}).

\begin{figure}
    \label{fig:sample-schema}
    \centering
    \begin{tikzpicture}
        [
            > = stealth',
            shorten > = 1pt,
            node distance = 2cm and 2.5cm,
            set/.style = {
                draw, rectangle, thick, font=\sffamily,
                minimum width=1.5cm, minimum height=.75cm,
                text height=1.5ex, text depth=.25ex},
            map/.style = {font=\small\sffamily}
        ]
        \node [set] (Dept) {Dept};
        \node [set] (Emp) [right=of Dept] {Emp};
        \node [set] (Text) [below=of Dept] {Text};
        \node [set] (Int) [below=of Emp] {Int};
        \draw [->] (Dept) to [bend right=15] node [map, right] {name} (Text);
        \draw [->] (Emp) to [bend right=15] node [map, right] {\;name} (Text);
        \draw [->] (Emp) to [bend left=15] node [map, right] {\;position} (Text);
        \draw [->] (Emp) to [bend left=15] node [map, right] {salary} (Int);
        \draw [->] (Emp) to node [map, above] {department} (Dept);
        \draw [->] (Emp) to [loop right] node [map, right] {manager} (Emp);
    \end{tikzpicture}
    \caption{Sample database schema}
\end{figure}

Functional database model appears to be a good candidate for a foundation
of a combinator-based query language.  Indeed, we can declare that any
function on an entity set is a database query.  Then for each database schema,
its attributes and relationships form a collection of primitive queries.
Composition of functions becomes a binary query combinator.  With these
considerations, we can write our first composite query.

\begin{example}
    Given an employee entity, show the name of their department.
    \begin{equation*}
        \Department{.}\Name: \Emp \to \Text
    \end{equation*}
\end{example}

In this example, $\Department{.}\Name$ is a query written in Rabbit notation,
$\Emp \to \Text$ is its signature.  The period $({.})$ denotes the composition
combinator, which is a polymorphic binary operator with signature
\begin{equation*}
        ({.}) : (A \to B) \times (B \to C) \to (A \to C).
\end{equation*}

Is this a viable foundation for a query language?  The approach looks
promising, but it's clear it has some major flaws.  Let us discuss them.

First, it is awkward that the query interface always demands an input.  It
means that we cannot express an input-free query like \emph{Show a list of all
departments}.  Moreover, queries would be impossible to execute if to run any
query, we'd need to give it an entity object, and an entity object could only
be obtained as a query output.

Second, relationships between entities got a direction arbitrarily assigned to
them.  Indeed, we chose to encode connection between departments and employees
as a primitive with input $\Emp$ and output $\Dept$.  But this connection is
symmetric and we may just as well be interested in finding, for any given
department, the corresponding set of employees.  However, this inverse
direction cannot be encoded as a query because it would lack a valid signature.
We could attempt to introduce a primitive
\begin{equation*}
    \Employee: \Dept \to \Emp,
\end{equation*}
but its signature would incorrectly imply that there is exactly one employee
per department.  The query interface is unable to express multivalued or
\emph{plural} relationships.

The interface also fails to capture the semantics of \emph{optional} attributes
and relationships.  Such is the relationship between employees and their
managers, which we encoded by primitive
\begin{equation*}
    \Manager: \Emp \to \Emp.
\end{equation*}
But its signature implies that every employee must have a manager, which is
evidently incorrect.  Apparently, pure functional interface is too restrictive
to express the variety of relationships between database entities.

To overcome these difficulties, we take the following course of action:
\begin{enumerate}
\item
Extend functional query interface so that it could support optional and plural
values.
\item
Add primitives that encode whole entity classes as well as inverse
relationships.
\item
Define combinators for common data operations: aggregation, filtering,
grouping, etc.
\end{enumerate}

This paper is organized as follows.

In Section~2, we introduce query cardinality as a mo\-nadic wrapper over its
output type, which allows us to complete our collection of primitive queries.
We also show how any database can be unfolded to the hierarchical form.

In Section~3, we define and demonstrate how to use combinators for data
traversal, aggregation, filtering and output selection.

In Section~4, we define quotient types and show how to use them for
grouping and cube operations.

In Section~5, we introduce combinators for exploring hierarchical
relationships.

In Section~6, we show how to extend the query interface with comonadic wrapper
over its input type to support context-aware combinators.  This gives us
ability to express queries with running aggregates and queries with parameters.

In Section~7, we formally describe the query interface and the composition
combinator.

In Section~8, we briefly discuss some related works.

